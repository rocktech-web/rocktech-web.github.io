

<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RockTechnology - Land Revenue CAD System</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* =========================================
           PROFESSIONAL ENTERPRISE UI CSS
           ========================================= */
        :root { 
            --bg-body: #f8fafc;
            --bg-panel: #ffffff;
            --text-main: #0f172a;
            --text-muted: #475569;
            --border-light: #e2e8f0;
            --border-dark: #cbd5e1;
            
            /* Corporate Accents */
            --primary: #2563eb; 
            --primary-hover: #1d4ed8;
            --secondary: #0f172a; 
            --secondary-hover: #1e293b;
            --success: #059669; 
            --danger: #dc2626; 
            
            /* Print Variables */
            --print-border: #000000;
        }

        body { 
            font-family: 'Poppins', sans-serif; 
            background-color: var(--bg-body); 
            color: var(--text-main);
            margin: 0; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }


        .header { text-align: center; margin-bottom: 15px; }
        .header h1 { color: var(--secondary); margin-bottom: 2px; font-size: 26px; font-weight: 700; letter-spacing: -0.5px;}
        .header p { color: var(--text-muted); font-size: 14px; margin: 0; font-weight: 500;}

        /* Panels & Toolbars */
        .panel { 
            background: var(--bg-panel); 
            padding: 12px 20px; 
            border-radius: 8px; 
            border: 1px solid var(--border-light);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
            margin-bottom: 12px; 
            width: 100%; 
            max-width: 1100px; 
            display: flex; 
            gap: 10px; 
            flex-wrap: wrap; 
            justify-content: center; 
            align-items: center; 
            box-sizing: border-box;
        }

        .btn { 
            padding: 8px 14px; 
            border: 1px solid var(--border-dark); 
            border-radius: 6px; 
            background: #f1f5f9;
            color: #334155;
            font-weight: 600; 
            font-family: 'Poppins', sans-serif; 
            font-size: 13px;
            cursor: pointer; 
            transition: all 0.2s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center;
        }
        .btn:hover { background: #e2e8f0; }
        
        .active-tool { 
            background: #eff6ff !important; 
            border-color: #7dd3fc !important; 
            color: #0284c7 !important; 
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        .btn-primary { background: var(--primary); border-color: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); border-color: var(--primary-hover); color: white;}
        
        .btn-dark { background: var(--secondary); border-color: var(--secondary); color: white; }
        .btn-dark:hover { background: var(--secondary-hover); border-color: var(--secondary-hover); color: white;}

        .btn-success { background: var(--success); border-color: var(--success); color: white; }
        .btn-danger { background: var(--danger); border-color: var(--danger); color: white; }
        .btn-danger-outline { border-color: var(--danger); color: var(--danger); background: transparent; }
        .btn-danger-outline:hover { background: #fee2e2; }

        .control-group { display: flex; align-items: center; gap: 8px; font-size: 13px; font-weight: 600; color: var(--text-muted); background: #f8fafc; padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-light);}
        .number-input { width: 45px; padding: 4px; border: 1px solid var(--border-dark); border-radius: 4px; font-family: 'Poppins', sans-serif; font-weight: 600; text-align: center; color: var(--text-main);}
        .text-input { padding: 6px 10px; border: 1px solid var(--border-dark); border-radius: 4px; font-family: 'Poppins', sans-serif; font-weight: 500; font-size: 13px; width: 180px;}

        .viewport { width: 160mm; height: 174mm; border: 1px solid var(--border-dark); background: #e2e8f0; overflow: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.05); position: relative; border-radius: 4px;}
        .canvas-wrapper { width: 160mm; height: 174mm; background: white; transform-origin: top left; transition: transform 0.1s ease; position: relative; }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        
        #instruction { color: var(--primary); font-weight: 600; margin-bottom: 10px; text-align: center; font-size: 14px;}
        
        .floating-input-container { position: absolute; background: white; border: 1px solid var(--border-dark); border-radius: 6px; padding: 10px; z-index: 1000; box-shadow: 0 10px 25px rgba(0,0,0,0.15); display: flex; flex-direction: column; gap: 8px;}
        .floating-textarea { font-family: 'Poppins', sans-serif; font-size: 14px; padding: 8px; font-weight: 500; outline: none; border: 1px solid var(--border-dark); border-radius: 4px; resize: both; min-width: 200px; min-height: 60px;}
        #cadDistanceBox { display: none; position: absolute; background: var(--secondary); color: white; padding: 4px 10px; border-radius: 4px; font-weight: 600; pointer-events: none; z-index: 10; font-size: 13px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);}

        /* Inline Form Fields */
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; font-weight: 600; color: var(--text-muted); margin-bottom: 4px; font-size: 12px;}
        .form-group input, .form-group textarea { width: 100%; padding: 8px; border: 1px solid var(--border-dark); border-radius: 6px; font-family: inherit; font-size: 13px; box-sizing: border-box; background: #ffffff; transition: 0.2s;}
        .form-group input:focus, .form-group textarea:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);}

        .divider { width: 1px; height: 24px; background: var(--border-dark); margin: 0 5px; }

        /* =========================================
           OFFICIAL A4 PRINT CSS 
           ========================================= */
        #printArea { display: none; }
        
        @media print {
            @page { size: A4; margin: 10mm; }
            body { margin: 0; padding: 0; background-color: transparent; }
            body > *:not(#printArea) { display: none !important; }
            
            #printArea { 
                display: block !important; 
                position: absolute; left: 0; top: 0; width: 100%; 
                font-family: 'Poppins', sans-serif; 
                color: #000; 
            }

            .document-container {
                width: 190mm; 
                height: 277mm; 
                margin: 0 auto;
                background-color: #fff;
                border: 1px solid var(--print-border);
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                overflow: hidden; 
            }

            .bold { font-weight: 700 !important; }
            .regular { font-weight: 400 !important; }
            .font-14 { font-size: 14pt !important; }
            .font-11 { font-size: 11pt !important; }

            .header-table { width: 100%; border-collapse: collapse; border-bottom: 1px solid var(--print-border); }
            .header-table > tbody > tr > td { border-right: 1px solid var(--print-border); padding: 8px 10px; vertical-align: top; line-height: 1.5; }
            .header-table > tbody > tr > td:last-child { border-right: none; }

            .header-left { width: 55%; }
            .header-mid { width: 30%; padding: 0 !important; }
            .header-right { width: 15%; text-align: center; vertical-align: middle !important; }
            .compass-img { width: 80px; height: auto; }

            .mid-table { width: 100%; height: 100%; border-collapse: collapse; }
            .mid-table td { border-bottom: 1px solid var(--print-border); padding: 10px; }
            .mid-table tr:last-child td { border-bottom: none; }
            .title-cell { text-align: center; vertical-align: middle; height: 5px; }
            .date-cell { text-align: center; vertical-align: bottom; height: 30px; padding-bottom: 10px; }

            .map-area { flex-grow: 1; min-height: 0; border-bottom: 1px solid var(--print-border); display: flex; justify-content: center; align-items: center; padding: 5px; box-sizing: border-box; overflow: hidden; }
            .map-area img { max-width: 100%; max-height: 100%; object-fit: contain; }

            .declaration-text { padding: 12px; text-align: center; }
            .signature-line { padding: 6px 10px; }

            .footer-layout-table { width: 100%; border-collapse: collapse; border-top: 1px solid var(--print-border); }
            .footer-layout-table > tbody > tr > td { vertical-align: top; }

            .footer-details-table { width: 100%; border-collapse: collapse; height: 100%; }
            .footer-details-table td { border-right: 1px solid var(--print-border); border-bottom: 1px solid var(--print-border); padding: 10px; vertical-align: middle; }
            .footer-details-table tr:last-child td { border-bottom: none; }
            .label-col { width: 30%; text-align: right; padding-right: 15px; }
            .value-col { width: 70%; }

            .patwari-block { display: flex; flex-direction: column; justify-content: flex-end; align-items: center; text-align: center; height: 100%; min-height: 140px; padding: 15px 10px; box-sizing: border-box; }
        }
    </style>
</head>
<body>


    <div class="header">
        <h1>RockTechnology - Master CAD</h1>
        <p>‡§™‡•ç‡§∞‡•ã‡§´‡•á‡§∂‡§®‡§≤ ‡§®‡•õ‡§∞‡•Ä ‡§®‡§ï‡•ç‡§∂‡§æ ‡§è‡§µ‡§Ç ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡•õ ‡§ú‡§®‡§∞‡•á‡§ü‡§∞</p>
    </div>

    <input type="file" id="projectInput" accept=".json" style="display: none;" />

    <div class="panel">
        <button class="btn" onclick="document.getElementById('projectInput').click()">‡§™‡•ç‡§∞‡•ã‡§ú‡•á‡§ï‡•ç‡§ü ‡§ñ‡•ã‡§≤‡•á‡§Ç</button>
        <button class="btn" onclick="saveProject()">‡§™‡•ç‡§∞‡•ã‡§ú‡•á‡§ï‡•ç‡§ü ‡§∏‡•á‡§µ ‡§ï‡§∞‡•á‡§Ç</button>
        <div class="divider"></div>
        <button class="btn" onclick="changeZoom(0.2)">‡•õ‡•Ç‡§Æ ‡§á‡§® (+)</button>
        <button class="btn" onclick="changeZoom(-0.2)">‡•õ‡•Ç‡§Æ ‡§Ü‡§â‡§ü (-)</button>
        <div class="divider"></div>
        <button class="btn" onclick="undo()">Undo</button>
        <button class="btn" onclick="redo()">Redo</button>
        <div class="divider"></div>
        <button class="btn" onclick="location.reload()">‡§®‡§Ø‡§æ ‡§®‡§ï‡•ç‡§∂‡§æ (Reset)</button>
    </div>

    <div class="panel" id="drawToolbar">
        <label class="btn btn-dark">‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç <input type="file" id="imageInput" accept="image/*" style="display: none;" /></label>
        <div class="divider"></div>
        <button class="btn" id="btnMain" onclick="setMode('main')">‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§Æ‡§æ‡§∞‡•ç‡§ó (Red)</button>
        <button class="btn" id="btnLink" onclick="setMode('link')">‡§≤‡§ø‡§Ç‡§ï ‡§Æ‡§æ‡§∞‡•ç‡§ó (Yellow)</button>
        <button class="btn" id="btnKachchi" onclick="setMode('kachchi')">‡§ï‡§ö‡•ç‡§ö‡§æ ‡§∞‡§æ‡§∏‡•ç‡§§‡§æ (Dash)</button>
        <button class="btn" id="btnRail" onclick="setMode('rail')">‡§∞‡•á‡§≤ ‡§≤‡§æ‡§á‡§®</button>
        <button class="btn" id="btnPlot" onclick="setMode('plot')">‡§™‡•ç‡§≤‡•â‡§ü ‡§≤‡§æ‡§á‡§®</button>
        <button class="btn" id="btnText" onclick="setMode('text')">‡§´‡•ç‡§∞‡•Ä ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü</button>
        <div class="divider"></div>
        <button class="btn btn-primary" onclick="generateLineArt()">‡§≤‡§æ‡§á‡§® ‡§Ü‡§∞‡•ç‡§ü ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç</button>
    </div>

    <div class="panel" id="docDetailsPanel" style="display: none; flex-direction: column; align-items: stretch; gap: 5px; background: #f0fdfa; border-color: #5eead4;">
        <div style="font-weight: 700; color: var(--success); border-bottom: 1px solid #ccfbf1; padding-bottom: 8px; margin-bottom: 5px; font-size: 15px; display: flex; justify-content: space-between; align-items: center;">
            <span>üìù ‡§Ü‡§ß‡§ø‡§ï‡§æ‡§∞‡§ø‡§ï ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡•õ ‡§ï‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ (A4 Print)</span>
            <span style="font-size: 12px; color: var(--text-muted); font-weight: 500;">‡§™‡•ç‡§∞‡•ã‡§ú‡•á‡§ï‡•ç‡§ü ‡§∏‡•á‡§µ ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ ‡§Ø‡§π ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§≠‡•Ä ‡§∏‡•á‡§µ ‡§π‡•ã ‡§ú‡§æ‡§è‡§ó‡§æ‡•§</span>
        </div>
        <div style="display: flex; gap: 15px; flex-wrap: wrap;">
            <div class="form-group" style="flex: 1; min-width: 250px; margin-bottom: 0;">
                <label>‡§ï‡§æ‡§∞‡•ç‡§Ø‡§æ‡§≤‡§Ø ‡§ï‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ (‡§ä‡§™‡§∞ ‡§¨‡§æ‡§à‡§Ç ‡§ì‡§∞):</label>
                <textarea id="docOffice" rows="4" style="resize: vertical;">‡§ï‡§æ‡§∞‡•ç‡§Ø‡§æ‡§≤‡§Ø ‡§™‡§ü‡§µ‡§æ‡§∞‡•Ä ‡§π‡§≤‡•ç‡§ï‡§æ ‡§¨‡•à‡§¢‡§º‡§®, ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï 14&#10;‡§∞‡§æ.‡§®‡§ø. ‡§Æ‡§£‡•ç‡§°‡§≤: ‡§¨‡•à‡§¢‡§º‡§®, ‡§§‡§π‡§∏‡•Ä‡§≤: ‡§∏‡§ø‡§Ç‡§ó‡§∞‡•å‡§≤‡•Ä ‡§®‡§ó‡§∞&#10;‡§ú‡§ø‡§≤‡§æ: ‡§∏‡§ø‡§Ç‡§ó‡§∞‡•å‡§≤‡•Ä, ‡§Æ‡§ß‡•ç‡§Ø ‡§™‡•ç‡§∞‡§¶‡•á‡§∂</textarea>
            </div>
            <div class="form-group" style="flex: 1; min-width: 250px; margin-bottom: 0;">
                <label>‡§™‡§ü‡§µ‡§æ‡§∞‡•Ä ‡§π‡§∏‡•ç‡§§‡§æ‡§ï‡•ç‡§∑‡§∞ ‡§µ‡§ø‡§µ‡§∞‡§£ (‡§®‡•Ä‡§ö‡•á ‡§¶‡§æ‡§à‡§Ç ‡§ì‡§∞):</label>
                <textarea id="docPatwari" rows="4" style="resize: vertical;">‡§π‡§≤‡•ç‡§ï‡§æ ‡§¨‡•à‡§¢‡§º‡§®, ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï 14&#10;‡§∞‡§æ.‡§®‡§ø. ‡§Æ‡§£‡•ç‡§°‡§≤: ‡§¨‡•à‡§¢‡§º‡§®&#10;‡§§‡§π‡§∏‡•Ä‡§≤: ‡§∏‡§ø‡§Ç‡§ó‡§∞‡•å‡§≤‡•Ä ‡§®‡§ó‡§∞</textarea>
            </div>
        </div>
        <div style="display: flex; gap: 15px; flex-wrap: wrap;">
            <div class="form-group" style="flex: 1; min-width: 150px; margin-bottom: 0;">
                <label>‡§ó‡•ç‡§∞‡§æ‡§Æ/‡§®‡§ó‡§∞:</label>
                <input type="text" id="docVillage" value="‡§ó‡§®‡§ø‡§Ø‡§æ‡§∞‡•Ä">
            </div>
            <div class="form-group" style="flex: 1; min-width: 150px; margin-bottom: 0;">
                <label>‡§¶‡§ø‡§®‡§æ‡§Ç‡§ï:</label>
                <input type="text" id="docDate" placeholder="DD/MM/YYYY">
            </div>
            <div class="form-group" style="flex: 2; min-width: 250px; margin-bottom: 0;">
                <label>‡§ñ‡§∏‡§∞‡§æ, ‡§∞‡§ï‡§µ‡§æ ‡§µ ‡§≠‡•Ç-‡§∏‡•ç‡§µ‡§æ‡§Æ‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£:</label>
                <textarea id="docKhasra" rows="4" style="resize: vertical;">1388/1/2/2 ‡§∞‡§ï‡§µ‡§æ 0.0220 ‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞ (‡§≠‡•Ç‡§Æ‡§ø ‡§∏‡•ç‡§µ‡§æ‡§Æ‡•Ä ‡§ï‡•Å‡§∏‡•Å‡§Æ ‡§ï‡§≤‡•Ä ‡§ó‡•Å‡§™‡•ç‡§§‡§æ ‡§™‡§§‡§ø ‡§∏‡•Å‡§∞‡•á‡§®‡•ç‡§¶‡•ç‡§∞ ‡§™‡•ç‡§∞‡§∏‡§æ‡§¶ ‡§ó‡•Å‡§™‡•ç‡§§‡§æ)</textarea>
            </div>
        </div>
    </div>

    <div class="panel" id="editToolbar" style="display: none;">
        <button class="btn btn-danger" id="btnTrim" onclick="setEditMode('trim')">‡§ï‡•à‡§Ç‡§ö‡•Ä (‡§ï‡•ç‡§∞‡•â‡§∏‡§ø‡§Ç‡§ó ‡§π‡§ü‡§æ‡§è‡§Ç)</button>
        <button class="btn" id="btnEditLine" onclick="setEditMode('editLine')">‡§≤‡§æ‡§á‡§® ‡§ñ‡§ø‡§∏‡§ï‡§æ‡§è‡§Ç (Nodes)</button>
        <div class="divider"></div>
        <button class="btn" id="btnSmartText" onclick="setEditMode('smartText')">‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§®‡§æ‡§Æ (‡§∏‡•ú‡§ï ‡§™‡§∞)</button>
        <button class="btn" id="btnFreeTextEdit" onclick="setEditMode('freeText')">‡§´‡•ç‡§∞‡•Ä ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü</button>
        <button class="btn btn-dark" id="btnEditText" onclick="setEditMode('editText')">‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü / ‡§è‡§°‡§ø‡§ü ‡§ï‡§∞‡•á‡§Ç</button>
        
        <div class="control-group" id="textControls" style="display: none;">
            <input type="text" id="textContentInput" class="text-input" placeholder="‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§∏‡•Å‡§ß‡§æ‡§∞‡•á‡§Ç..." oninput="updateTextProp('content', this.value)" onchange="saveState()">
            <label>‡§∏‡§æ‡§á‡•õ:</label>
            <input type="range" id="textSizeSlider" min="15" max="100" value="35" style="width:70px;" oninput="updateTextProp('size', this.value)" onchange="saveState()">
            <label>‡§ò‡•Å‡§Æ‡§æ‡§µ:</label>
            <input type="range" id="textAngleSlider" min="-180" max="180" value="0" style="width:70px;" oninput="updateTextProp('angle', this.value)" onchange="saveState()">
            <button class="btn btn-danger" style="padding: 4px 10px; margin-left: 10px; font-size: 12px;" onclick="deleteSelectedText()">üóëÔ∏è ‡§°‡§ø‡§≤‡•Ä‡§ü</button>
        </div>
    </div>

    <div class="panel" id="sliderPanel">
        <div class="control-group">
            <label style="color:#c0392b;">‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∏‡•ú‡§ï:</label>
            <input type="range" id="mainWidthRange" min="10" max="500" value="35" oninput="syncWidths('main', this.value)">
            <input type="number" id="mainWidthNum" class="number-input" min="10" max="500" value="75" oninput="syncWidths('main', this.value)"> px
        </div>
        <div class="control-group">
            <label style="color:#d35400;">‡§≤‡§ø‡§Ç‡§ï ‡§∏‡•ú‡§ï:</label>
            <input type="range" id="linkWidthRange" min="5" max="500" value="25" oninput="syncWidths('link', this.value)">
            <input type="number" id="linkWidthNum" class="number-input" min="5" max="500" value="55" oninput="syncWidths('link', this.value)"> px
        </div>
        <div class="control-group">
            <label style="color:#8e44ad;">‡§ï‡§ö‡•ç‡§ö‡§æ ‡§∞‡§æ‡§∏‡•ç‡§§‡§æ:</label>
            <input type="range" id="kachchiWidthRange" min="5" max="500" value="20" oninput="syncWidths('kachchi', this.value)">
            <input type="number" id="kachchiWidthNum" class="number-input" min="5" max="500" value="40" oninput="syncWidths('kachchi', this.value)"> px
        </div>
    </div>

    <div class="panel" id="exportPanel" style="display: none; background: #f8fafc; border-color: #cbd5e1;">
        <span style="font-weight: 600; color: var(--text-muted); margin-right: 10px;">‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü:</span>
        <button class="btn btn-success" onclick="generateOfficialPDF()" style="font-size: 14px;">üñ®Ô∏è ‡§Ü‡§ß‡§ø‡§ï‡§æ‡§∞‡§ø‡§ï ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡•õ ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü (A4 Form)</button>
        <button class="btn btn-dark" onclick="downloadSVG()">SVG (Word Shapes)</button>
        <button class="btn" onclick="downloadImage('png')">PNG</button>
        <button class="btn" onclick="downloadImage('jpeg')">JPG</button>
    </div>

    <div id="instruction">‡§™‡•ç‡§∞‡•ã‡§ú‡•á‡§ï‡•ç‡§ü ‡§ñ‡•ã‡§≤‡•á‡§Ç ‡§Ø‡§æ ‡§®‡§Ø‡§æ ‡§Æ‡•à‡§™ ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞ ‡§ï‡§æ‡§Æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§</div>

    <div class="viewport" id="viewport">
        <div class="canvas-wrapper" id="canvasWrapper">
            <canvas id="mapCanvas" width="1600" height="1740"></canvas>
            <div id="cadDistanceBox">‡§¶‡•Ç‡§∞‡•Ä: <span id="cadDistValue"></span></div>
        </div>
    </div>

    <div id="printArea">
        <div class="document-container">
            <table class="header-table">
                <tr>
                    <td class="header-left">
                        <div id="printOfficeLine1" class="font-14 bold"></div>
                        <div id="printOfficeLine2" class="font-11 bold" style="white-space: pre-line; margin-top: 2px;"></div>
                    </td>
                    <td class="header-mid">
                        <table class="mid-table">
                            <tr>
                                <td class="title-cell font-14 bold">‡§®‡§ú‡§∞‡•Ä ‡§®‡§ï‡•ç‡§∂‡§æ (‡§ö‡•å‡§π‡§¶‡•ç‡§¶‡•Ä)</td>
                            </tr>
                            <tr>
                                <td class="date-cell font-11 regular">
                                    ‡§¶‡§ø‡§®‡§æ‡§Ç‡§ï : <span id="printDateValue" class="bold">_ _ _ _ _ _ _ _ 2026</span>
                                </td>
                            </tr>
                        </table>
                    </td>
                    <td class="header-right">
                        <img src="https://png.pngtree.com/png-vector/20230131/ourmid/pngtree-beautiful-compass-icon-vector-illustration-png-image_6580312.png" alt="Compass" class="compass-img">
                    </td>
                </tr>
            </table>

            <div class="map-area">
                <img id="printMapImage" style="width: 100%; height: 100%; object-fit: contain;" src="">
            </div>

            <div class="declaration-text font-11 regular">
                ‡§Ü‡§µ‡•á‡§¶‡§ï/‡§≠‡•Ç‡§Æ‡§ø ‡§∏‡•ç‡§µ‡§æ‡§Æ‡•Ä(‡§ó‡§£) ‡§∏‡•á ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§è‡§µ‡§Ç ‡§Æ‡•å‡§ï‡§æ ‡§ú‡§æ‡§Ç‡§ö ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§®‡§ú‡§∞‡•Ä ‡§®‡§ï‡•ç‡§∂‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§ø‡§Ø‡§æ‡•§
            </div>

            <div class="signature-line font-11 regular">
                ‡§π‡§∏‡•ç‡§§‡§æ. ‡§Ü‡§µ‡•á‡§¶‡§ï(‡§ó‡§£) ----------------------------------------
            </div>

            <table class="footer-layout-table">
                <tr>
                    <td style="width: 70%; padding: 0;">
                        <table class="footer-details-table">
                            <tr>
                                <td class="label-col font-11 regular">‡§ó‡•ç‡§∞‡§æ‡§Æ/‡§®‡§ó‡§∞:</td>
                                <td class="value-col font-11 bold" id="printVillage"></td>
                            </tr>
                            <tr>
                                <td class="label-col font-11 regular">‡§ñ‡§∏‡§∞‡§æ, ‡§∞‡§ï‡§µ‡§æ ‡§µ ‡§≠‡•Ç-<br>‡§∏‡•ç‡§µ‡§æ‡§Æ‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£:</td>
                                <td class="value-col font-11 bold" id="printKhasra"></td>
                            </tr>
                        </table>
                    </td>
                    <td style="width: 30%; padding: 0;">
                        <div class="patwari-block">
                            <div class="font-11 bold" style="margin-bottom: 5px;">‡§™‡§ü‡§µ‡§æ‡§∞‡•Ä</div>
                            <div class="font-11" id="printPatwari" style="white-space: pre-line;"></div>
                        </div>
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <script>

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvasWrapper');
        const cadBox = document.getElementById('cadDistanceBox');
        const cadValue = document.getElementById('cadDistValue');
        
        let uploadedImage = null; let mode = null; let editMode = null; 
        let isGenerated = false; let currentZoom = 1;
        
        let historyStack = []; let finalSegments = []; let finalTexts = [];
        let undoStack = []; let redoStack = [];
        
        function saveProject() {
            const projectData = {
                version: "1.1", 
                imgSrc: uploadedImage ? uploadedImage.src : null,
                historyStack: historyStack, 
                finalSegments: finalSegments, 
                finalTexts: finalTexts,
                isGenerated: isGenerated,
                widths: { 
                    main: document.getElementById('mainWidthNum').value, 
                    link: document.getElementById('linkWidthNum').value, 
                    kachchi: document.getElementById('kachchiWidthNum').value 
                },
                docDetails: {
                    office: document.getElementById('docOffice').value,
                    village: document.getElementById('docVillage').value,
                    date: document.getElementById('docDate').value,
                    khasra: document.getElementById('docKhasra').value,
                    patwari: document.getElementById('docPatwari').value
                }
            };
            const blob = new Blob([JSON.stringify(projectData)], {type: "application/json"});
            saveAs(blob, "RockTech_Project.json");
        }

        document.getElementById('projectInput').addEventListener('change', function(e) {
            const file = e.target.files[0]; if(!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    const data = JSON.parse(ev.target.result);
                    historyStack = data.historyStack || []; 
                    finalSegments = data.finalSegments || []; 
                    finalTexts = data.finalTexts || []; 
                    isGenerated = data.isGenerated || false;
                    
                    // FIX: Set widths directly to DOM without triggering regenerateSegments()
                    if(data.widths) {
                        ['main', 'link', 'kachchi'].forEach(type => {
                            if(data.widths[type] !== undefined) {
                                document.getElementById(type + 'WidthRange').value = data.widths[type];
                                document.getElementById(type + 'WidthNum').value = data.widths[type];
                            }
                        });
                    }
                    
                    if(data.docDetails) {
                        document.getElementById('docOffice').value = data.docDetails.office || "";
                        document.getElementById('docVillage').value = data.docDetails.village || "";
                        document.getElementById('docDate').value = data.docDetails.date || "";
                        document.getElementById('docKhasra').value = data.docDetails.khasra || "";
                        document.getElementById('docPatwari').value = data.docDetails.patwari || "";
                    }

                    if(data.imgSrc) {
                        uploadedImage = new Image(); 
                        uploadedImage.onload = () => restoreState({isGenerated, historyStack, finalSegments, finalTexts}); 
                        uploadedImage.src = data.imgSrc;
                    } else { 
                        uploadedImage = null; 
                        restoreState({isGenerated, historyStack, finalSegments, finalTexts}); 
                    }
                } catch(err) { alert("‡§´‡§æ‡§á‡§≤ ‡§ï‡•ã ‡§™‡•ù‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø! ‡§∏‡§π‡•Ä RockTech_Project.json ‡§´‡§æ‡§á‡§≤ ‡§ö‡•Å‡§®‡•á‡§Ç‡•§"); }
            };
            reader.readAsText(file);
        });

        function saveState() {
            undoStack.push({ isGenerated: isGenerated, historyStack: JSON.parse(JSON.stringify(historyStack)), finalSegments: JSON.parse(JSON.stringify(finalSegments)), finalTexts: JSON.parse(JSON.stringify(finalTexts)) });
            redoStack = []; 
        }

        function undo() {
            if(undoStack.length > 0) {
                redoStack.push({ isGenerated, historyStack: JSON.parse(JSON.stringify(historyStack)), finalSegments: JSON.parse(JSON.stringify(finalSegments)), finalTexts: JSON.parse(JSON.stringify(finalTexts)) });
                restoreState(undoStack.pop());
            }
        }

        function redo() {
            if(redoStack.length > 0) {
                undoStack.push({ isGenerated, historyStack: JSON.parse(JSON.stringify(historyStack)), finalSegments: JSON.parse(JSON.stringify(finalSegments)), finalTexts: JSON.parse(JSON.stringify(finalTexts)) });
                restoreState(redoStack.pop());
            }
        }

        function restoreState(state) {
            isGenerated = state.isGenerated; historyStack = state.historyStack; finalSegments = state.finalSegments; finalTexts = state.finalTexts;
            
            document.getElementById('drawToolbar').style.display = isGenerated ? 'none' : 'flex';
            document.getElementById('sliderPanel').style.display = isGenerated ? 'none' : 'flex'; // Hide sliders if generated
            document.getElementById('editToolbar').style.display = isGenerated ? 'flex' : 'none';
            document.getElementById('exportPanel').style.display = isGenerated ? 'flex' : 'none';
            document.getElementById('docDetailsPanel').style.display = isGenerated ? 'flex' : 'none';
            
            if(!isGenerated) { currentPath = []; mode = null; document.querySelectorAll('.active-tool').forEach(el => el.classList.remove('active-tool')); }
            selectedTextIdx = -1; hoveredNode = null; drawCanvas();
        }

        function changeZoom(delta) {
            currentZoom += delta; if(currentZoom < 0.4) currentZoom = 0.4; if(currentZoom > 4) currentZoom = 4;
            wrapper.style.transform = `scale(${currentZoom})`; wrapper.style.width = `calc(160mm * ${currentZoom})`; wrapper.style.height = `calc(174mm * ${currentZoom})`;
        }

        let currentPath = []; let mousePos = {x: 0, y: 0}; let typedDistance = ""; let snapPoint = null; 
        let hoverSegmentIdx = -1; let selectedTextIdx = -1; let isDraggingText = false;
        let hoveredNode = null; let draggedNode = null; 

        document.getElementById('imageInput').addEventListener('change', function(e) {
            if(e.target.files && e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    uploadedImage = new Image(); uploadedImage.onload = () => { saveState(); drawCanvas(); }; uploadedImage.src = event.target.result;
                }
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        function syncWidths(type, val) {
            if(val === "") return; document.getElementById(type + 'WidthRange').value = val; document.getElementById(type + 'WidthNum').value = val;
            if(isGenerated) { regenerateSegments(); drawCanvas(); } else { drawCanvas(); }
        }

        function getWidth(type) { return parseInt(document.getElementById(type + 'WidthNum').value) || 20; }

        function setMode(newMode) {
            if(isGenerated) return;
            if(currentPath.length > 0) { saveState(); historyStack.push({ type: mode, points: [...currentPath] }); currentPath = []; typedDistance=""; }
            mode = newMode;
            ['btnMain', 'btnLink', 'btnKachchi', 'btnRail', 'btnPlot', 'btnText'].forEach(id => document.getElementById(id).classList.remove('active-tool'));
            let btnMap = {'main':'btnMain', 'link':'btnLink', 'kachchi':'btnKachchi', 'rail':'btnRail', 'plot':'btnPlot', 'text':'btnText'};
            if(btnMap[mode]) document.getElementById(btnMap[mode]).classList.add('active-tool');
        }

        function setEditMode(newMode) {
            editMode = newMode;
            ['btnTrim', 'btnSmartText', 'btnFreeTextEdit', 'btnEditText', 'btnEditLine'].forEach(id => document.getElementById(id).classList.remove('active-tool'));
            document.getElementById('textControls').style.display = 'none';

            if(editMode === 'trim') { document.getElementById('btnTrim').classList.add('active-tool'); document.getElementById('instruction').textContent = "‡§ï‡•à‡§Ç‡§ö‡•Ä: ‡§è‡§ï‡•ç‡§∏‡•ç‡§ü‡•ç‡§∞‡§æ ‡§≤‡§æ‡§á‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§ï‡•á ‡§Æ‡§ø‡§ü‡§æ‡§è‡§Ç‡•§"; canvas.style.cursor = 'crosshair'; }
            if(editMode === 'editLine') { document.getElementById('btnEditLine').classList.add('active-tool'); document.getElementById('instruction').textContent = "‡§®‡•ã‡§° ‡§ñ‡§ø‡§∏‡§ï‡§æ‡§è‡§Ç: ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§≤‡§æ‡§á‡§® ‡§ï‡•á ‡§ï‡•ã‡§®‡•á (‡§π‡§∞‡•á ‡§ó‡•ã‡§≤‡•á) ‡§ï‡•ã ‡§™‡§ï‡•ú ‡§ï‡§∞ ‡§ñ‡§ø‡§∏‡§ï‡§æ‡§è‡§Ç‡•§"; canvas.style.cursor = 'move'; }
            if(editMode === 'smartText') { document.getElementById('btnSmartText').classList.add('active-tool'); document.getElementById('instruction').textContent = "‡§Æ‡§æ‡§∞‡•ç‡§ó ‡§®‡§æ‡§Æ: ‡§∏‡•ú‡§ï ‡§ï‡•Ä ‡§≤‡§æ‡§á‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"; canvas.style.cursor = 'pointer'; }
            if(editMode === 'freeText') { document.getElementById('btnFreeTextEdit').classList.add('active-tool'); document.getElementById('instruction').textContent = "‡§´‡•ç‡§∞‡•Ä ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü: ‡§ï‡§π‡•Ä‡§Ç ‡§≠‡•Ä ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§ï‡•á ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§"; canvas.style.cursor = 'text'; }
            if(editMode === 'editText') { 
                document.getElementById('btnEditText').classList.add('active-tool'); 
                document.getElementById('instruction').textContent = "‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§è‡§°‡§ø‡§ü: ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§ñ‡§ø‡§∏‡§ï‡§æ‡§è‡§Ç, ‡§∏‡§æ‡§á‡•õ ‡§¨‡§¶‡§≤‡•á‡§Ç, ‡§ò‡•Å‡§Æ‡§æ‡§è‡§Ç ‡§Ø‡§æ ‡§∂‡§¨‡•ç‡§¶ ‡§∏‡•Å‡§ß‡§æ‡§∞‡•á‡§Ç‡•§"; 
                document.getElementById('textControls').style.display = 'flex'; canvas.style.cursor = 'default'; 
            }
            hoverSegmentIdx = -1; selectedTextIdx = -1; hoveredNode = null; draggedNode = null; drawCanvas();
        }

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
        }

        function spawnFloatingTextarea(e, onSave) {
            if(document.querySelector('.floating-input-container')) return; 
            const container = document.createElement('div'); container.className = 'floating-input-container';
            container.style.left = e.pageX + 'px'; container.style.top = (e.pageY - 20) + 'px';

            const textarea = document.createElement('textarea'); textarea.className = 'floating-textarea'; textarea.placeholder = "‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≤‡§ø‡§ñ‡•á‡§Ç... (‡§®‡§à ‡§≤‡§æ‡§á‡§® ‡§ï‡•á ‡§≤‡§ø‡§è Enter ‡§¶‡§¨‡§æ‡§è‡§Ç)";
            const btn = document.createElement('button'); btn.textContent = "‚úî ‡§∏‡•á‡§µ ‡§ï‡§∞‡•á‡§Ç"; btn.className = "btn btn-primary"; btn.style.marginTop = "5px";

            container.appendChild(textarea); container.appendChild(btn); document.body.appendChild(container); textarea.focus();

            const saveText = () => {
                let val = textarea.value.trim(); if(val !== "") onSave(val);
                if(document.body.contains(container)) document.body.removeChild(container); drawCanvas();
            };
            btn.addEventListener('click', saveText);
        }

        function promptSingleLine(msg, onSave) { let val = prompt(msg); if(val && val.trim() !== "") onSave(val.trim()); }

        function updateTextProp(prop, val) {
            if (isGenerated && selectedTextIdx !== -1 && finalTexts[selectedTextIdx]) {
                if(prop === 'size') finalTexts[selectedTextIdx].fontSize = parseInt(val);
                if(prop === 'angle') finalTexts[selectedTextIdx].angle = parseInt(val) * (Math.PI / 180); 
                if(prop === 'content') finalTexts[selectedTextIdx].text = val; 
                drawCanvas();
            }
        }
        function deleteSelectedText() {
            if (isGenerated && selectedTextIdx !== -1) {
                saveState();
                finalTexts.splice(selectedTextIdx, 1);
                selectedTextIdx = -1;
                document.getElementById('textContentInput').value = "";
                drawCanvas(); 
            }
        }

        function findClosestText(p) {
            let minDist = 40; let bestIdx = -1;
            for(let i=0; i<finalTexts.length; i++) {
                let dist = Math.hypot(p.x - finalTexts[i].x, p.y - finalTexts[i].y);
                if(dist < minDist) { minDist = dist; bestIdx = i; }
            }
            return bestIdx;
        }

        function findClosestNode(p) {
            let minDist = 30; let bestNode = null;
            for(let i=0; i<finalSegments.length; i++) {
                let d1 = Math.hypot(p.x - finalSegments[i].A.x, p.y - finalSegments[i].A.y); let d2 = Math.hypot(p.x - finalSegments[i].B.x, p.y - finalSegments[i].B.y);
                if(d1 < minDist) { minDist = d1; bestNode = {segIdx: i, isA: true}; } if(d2 < minDist) { minDist = d2; bestNode = {segIdx: i, isA: false}; }
            }
            return bestNode;
        }

        window.addEventListener('keydown', (e) => {
            if(!isGenerated && currentPath.length > 0 && mode && mode !== 'text') {
                if((e.key >= '0' && e.key <= '9') || e.key === '.') { typedDistance += e.key; drawCanvas(); } 
                else if(e.key === 'Backspace') { typedDistance = typedDistance.slice(0, -1); drawCanvas(); } 
                else if(e.key === 'Enter' && typedDistance !== "") {
                    let lastPt = currentPath[currentPath.length - 1]; let angle = Math.atan2(mousePos.y - lastPt.y, mousePos.x - lastPt.x);
                    saveState();
                    currentPath.push({x: lastPt.x + Math.cos(angle) * parseFloat(typedDistance), y: lastPt.y + Math.sin(angle) * parseFloat(typedDistance)});
                    typedDistance = ""; drawCanvas();
                }
            }
        });

        wrapper.addEventListener('mousemove', (e) => {
            mousePos = getCoords(e);
            if (isGenerated) {
                if (editMode === 'trim' || editMode === 'smartText') { hoverSegmentIdx = findClosestSegment(mousePos); drawCanvas(); } 
                else if (editMode === 'editLine') {
                    if (draggedNode) {
                        if(draggedNode.isA) finalSegments[draggedNode.segIdx].A = {x: mousePos.x, y: mousePos.y}; else finalSegments[draggedNode.segIdx].B = {x: mousePos.x, y: mousePos.y}; drawCanvas();
                    } else { hoveredNode = findClosestNode(mousePos); drawCanvas(); }
                }
                else if (editMode === 'editText' && isDraggingText && selectedTextIdx !== -1) { finalTexts[selectedTextIdx].x = mousePos.x; finalTexts[selectedTextIdx].y = mousePos.y; drawCanvas(); }
            } else if (!isGenerated && currentPath.length > 0) {
                let startPt = currentPath[0]; let distToStart = Math.hypot(mousePos.x - startPt.x, mousePos.y - startPt.y); snapPoint = (distToStart < 30 && currentPath.length > 2) ? startPt : null; drawCanvas(); 
            }
        });

        window.addEventListener('mouseup', () => { isDraggingText = false; if(draggedNode) { draggedNode = null; saveState(); } });

        wrapper.addEventListener('mousedown', (e) => {
            if(document.querySelector('.floating-input-container')) return; 
            const coords = getCoords(e);

            if (isGenerated) {
                if (editMode === 'trim' && hoverSegmentIdx !== -1) { saveState(); finalSegments.splice(hoverSegmentIdx, 1); hoverSegmentIdx = -1; drawCanvas(); }
                else if (editMode === 'editLine' && hoveredNode) { saveState(); draggedNode = hoveredNode; }
                else if (editMode === 'smartText') {
                    let segIdx = findClosestSegment(coords);
                    if(segIdx !== -1) {
                        let seg = finalSegments[segIdx]; let midX = (seg.A.x + seg.B.x) / 2; let midY = (seg.A.y + seg.B.y) / 2;
                        let angle = Math.atan2(seg.B.y - seg.A.y, seg.B.x - seg.A.x); if (angle > Math.PI/2) angle -= Math.PI; if (angle < -Math.PI/2) angle += Math.PI;
                        promptSingleLine("‡§Æ‡§æ‡§∞‡•ç‡§ó ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç:", (val) => { saveState(); let size = parseInt(document.getElementById('textSizeSlider').value) || 35; finalTexts.push({ text: val, x: midX, y: midY, angle: angle, fontSize: size }); drawCanvas(); });
                    } else { alert("‡§∏‡•ú‡§ï ‡§ï‡•Ä ‡§≤‡§æ‡§á‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"); }
                }
                else if (editMode === 'freeText') {
                    spawnFloatingTextarea(e, (val) => { saveState(); let size = parseInt(document.getElementById('textSizeSlider').value) || 35; finalTexts.push({ text: val, x: coords.x, y: coords.y, angle: 0, fontSize: size }); drawCanvas(); });
                }
                else if (editMode === 'editText') {
                    let clickedIdx = findClosestText(coords);
                    if(clickedIdx !== -1) {
                        saveState(); selectedTextIdx = clickedIdx; isDraggingText = true;
                        document.getElementById('textSizeSlider').value = finalTexts[clickedIdx].fontSize || 35;
                        document.getElementById('textAngleSlider').value = Math.round((finalTexts[clickedIdx].angle || 0) * (180/Math.PI));
                        document.getElementById('textContentInput').value = finalTexts[clickedIdx].text; 
                        drawCanvas();
                    } else { selectedTextIdx = -1; document.getElementById('textContentInput').value = ""; drawCanvas(); }
                }
                return;
            }

            if(!mode) return;
            if(mode === 'text') {
                spawnFloatingTextarea(e, (val) => { saveState(); let size = parseInt(document.getElementById('mainWidthNum').value) || 35; historyStack.push({ type: 'text', text: val, x: coords.x, y: coords.y, angle: 0, fontSize: size }); drawCanvas(); });
                return;
            }

            saveState();
            if(snapPoint) { currentPath.push({x: snapPoint.x, y: snapPoint.y}); historyStack.push({ type: mode, points: [...currentPath] }); currentPath = []; snapPoint = null; typedDistance = ""; } 
            else if(typedDistance !== "") { let lastPt = currentPath[currentPath.length - 1]; let angle = Math.atan2(coords.y - lastPt.y, coords.x - lastPt.x); currentPath.push({x: lastPt.x + Math.cos(angle) * parseFloat(typedDistance), y: lastPt.y + Math.sin(angle) * parseFloat(typedDistance)}); typedDistance = ""; } 
            else { currentPath.push(coords); }
            drawCanvas();
        });

        canvas.addEventListener('dblclick', () => {
            if(mode === 'text' || !mode || currentPath.length === 0 || isGenerated) return;
            saveState(); historyStack.push({ type: mode, points: [...currentPath] }); currentPath = []; typedDistance = ""; snapPoint = null; drawCanvas();
        });

        function getParallelPaths(pts, width) {
            let left = [], right = []; let halfW = width / 2;
            for(let i=0; i<pts.length; i++) {
                let p = pts[i]; let v1, v2;
                if(i === 0) { v1 = {x: pts[1].x - p.x, y: pts[1].y - p.y}; v2 = v1; } 
                else if (i === pts.length - 1) { v1 = {x: p.x - pts[i-1].x, y: p.y - pts[i-1].y}; v2 = v1; } 
                else { v1 = {x: p.x - pts[i-1].x, y: p.y - pts[i-1].y}; v2 = {x: pts[i+1].x - p.x, y: pts[i+1].y - p.y}; }
                let len1 = Math.hypot(v1.x, v1.y) || 1; v1 = {x: v1.x/len1, y: v1.y/len1}; let len2 = Math.hypot(v2.x, v2.y) || 1; v2 = {x: v2.x/len2, y: v2.y/len2};
                let tangent = {x: v1.x + v2.x, y: v1.y + v2.y}; let tLen = Math.hypot(tangent.x, tangent.y); if(tLen === 0) tangent = v1; else tangent = {x: tangent.x/tLen, y: tangent.y/tLen};
                let normal = {x: -tangent.y, y: tangent.x}; let n1 = {x: -v1.y, y: v1.x}; let dot = normal.x * n1.x + normal.y * n1.y; let miter = dot !== 0 ? 1/dot : 1;
                if (Math.abs(miter) > 3) miter = 3 * Math.sign(miter); 
                left.push({x: p.x + normal.x * halfW * miter, y: p.y + normal.y * halfW * miter}); right.push({x: p.x - normal.x * halfW * miter, y: p.y - normal.y * halfW * miter});
            } return {left, right};
        }

        function getRailwayTicks(pts) {
            let ticks = []; let tickSpacing = 30; let tickWidth = 25; let totalLength = 0; let distances = [0];
            for(let i=1; i<pts.length; i++) { totalLength += Math.hypot(pts[i].x - pts[i-1].x, pts[i].y - pts[i-1].y); distances.push(totalLength); }
            let currentDist = tickSpacing / 2; let pIdx = 1;
            while(currentDist < totalLength && pIdx < pts.length) {
                if(currentDist > distances[pIdx]) { pIdx++; continue; }
                let prev = pts[pIdx-1], curr = pts[pIdx]; let ratio = (currentDist - distances[pIdx-1]) / (distances[pIdx] - distances[pIdx-1]);
                let x = prev.x + (curr.x - prev.x) * ratio; let y = prev.y + (curr.y - prev.y) * ratio; let dx = curr.x - prev.x, dy = curr.y - prev.y; let len = Math.hypot(dx, dy) || 1; let nx = -dy/len, ny = dx/len;
                ticks.push([ {x: x + nx*(tickWidth/2), y: y + ny*(tickWidth/2)}, {x: x - nx*(tickWidth/2), y: y - ny*(tickWidth/2)} ]); currentDist += tickSpacing;
            } return ticks;
        }

        function getIntersection(A, B, C, D) {
            let bottom = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y); if (Math.abs(bottom) < 0.0001) return null;
            let t = ((D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x)) / bottom; let u = ((B.x - A.x) * (A.y - C.y) - (B.y - A.y) * (A.x - C.x)) / bottom;
            if (t > 0.01 && t < 0.99 && u > 0.01 && u < 0.99) { return { x: A.x + t * (B.x - A.x), y: A.y + t * (B.y - A.y) }; } return null;
        }

        function shatterSegments(segs) {
            let result = [...segs]; let foundSplit = true; let maxIters = 1000;
            while(foundSplit && maxIters-- > 0) {
                foundSplit = false;
                for(let i=0; i<result.length; i++) {
                    for(let j=i+1; j<result.length; j++) {
                        let intP = getIntersection(result[i].A, result[i].B, result[j].A, result[j].B);
                        if(intP) {
                            let s1 = result[i], s2 = result[j];
                            result.splice(j, 1, {A: intP, B: s2.B, dash: s2.dash}, {A: s2.A, B: intP, dash: s2.dash});
                            result.splice(i, 1, {A: intP, B: s1.B, dash: s1.dash}, {A: s1.A, B: intP, dash: s1.dash});
                            foundSplit = true; break;
                        }
                    } if(foundSplit) break;
                }
            } return result;
        }

        function pointToSegmentDistance(p, v, w) {
            let l2 = (v.x - w.x)**2 + (v.y - w.y)**2; if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = Math.max(0, Math.min(1, ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2)); return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        function findClosestSegment(p) {
            let minDist = 30; let bestIdx = -1;
            for(let i=0; i<finalSegments.length; i++) { let dist = pointToSegmentDistance(p, finalSegments[i].A, finalSegments[i].B); if(dist < minDist) { minDist = dist; bestIdx = i; } } return bestIdx;
        }

        function drawPathArray(ctx, pts) {
            if(pts.length < 2) return; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
            for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.stroke();
        }

        function renderDraftElement(el) {
            if(el.type === 'text') return;
            ctx.strokeStyle = el.type==='main' ? '#c0392b' : el.type==='link' ? '#d35400' : el.type==='kachchi' ? '#8e44ad' : '#16a085'; ctx.lineWidth = 4; 
            let w = el.type === 'main' ? getWidth('main') : el.type === 'link' ? getWidth('link') : getWidth('kachchi');

            if(el.type === 'rail' || el.type === 'plot') {
                drawPathArray(ctx, el.points); if(el.type === 'rail') getRailwayTicks(el.points).forEach(t => drawPathArray(ctx, t));
            } else {
                let parallels = getParallelPaths(el.points, w); if(el.type === 'kachchi') ctx.setLineDash([20, 20]);
                drawPathArray(ctx, parallels.left); drawPathArray(ctx, parallels.right); ctx.setLineDash([]); 
            }
        }

        function drawTexts(sourceArray, isFinal) {
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            sourceArray.forEach((el, idx) => {
                if(el.type === 'text' || el.text) {
                    let txt = el.text || el.text; let size = el.fontSize || 35; ctx.font = `600 ${size}px Poppins, Arial`;
                    ctx.fillStyle = (isFinal && idx === selectedTextIdx && editMode === 'editText') ? "#e74c3c" : (isFinal ? "#000" : "#2980b9");
                    ctx.save(); ctx.translate(el.x, el.y); ctx.rotate(el.angle || 0);
                    let lines = txt.split('\n'); let lineHeight = size * 1.2; let startY = -((lines.length - 1) * lineHeight) / 2;
                    lines.forEach((line, i) => { let lineY = startY + (i * lineHeight); if(isFinal) { ctx.lineWidth = Math.max(2, size/6); ctx.strokeStyle = "white"; ctx.strokeText(line, 0, lineY); } ctx.fillText(line, 0, lineY); });
                    ctx.restore();
                }
            });
        }

        function regenerateSegments() {
            let initialSegments = [];
            historyStack.forEach(el => {
                if (el.type === 'text') return; 
                let w = el.type === 'main' ? getWidth('main') : el.type === 'link' ? getWidth('link') : getWidth('kachchi');
                if (el.type === 'rail' || el.type === 'plot') {
                    for(let i=0; i<el.points.length-1; i++) initialSegments.push({A: el.points[i], B: el.points[i+1], dash: false});
                    if(el.type === 'rail') getRailwayTicks(el.points).forEach(t => initialSegments.push({A: t[0], B: t[1], dash: false}));
                } else {
                    let parallels = getParallelPaths(el.points, w); let isDash = el.type === 'kachchi';
                    for(let i=0; i<parallels.left.length-1; i++) initialSegments.push({A: parallels.left[i], B: parallels.left[i+1], dash: isDash});
                    for(let i=0; i<parallels.right.length-1; i++) initialSegments.push({A: parallels.right[i], B: parallels.right[i+1], dash: isDash});
                }
            });
            finalSegments = shatterSegments(initialSegments);
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); cadBox.style.display = 'none'; 
            if (!isGenerated) {
                if (uploadedImage) { 
                    ctx.globalAlpha = 0.4; let imgRatio = uploadedImage.width / uploadedImage.height; let canvasRatio = canvas.width / canvas.height; let drawW, drawH, drawX, drawY;
                    if (imgRatio > canvasRatio) { drawW = canvas.width; drawH = canvas.width / imgRatio; drawX = 0; drawY = (canvas.height - drawH) / 2; } 
                    else { drawH = canvas.height; drawW = canvas.height * imgRatio; drawX = (canvas.width - drawW) / 2; drawY = 0; }
                    ctx.drawImage(uploadedImage, drawX, drawY, drawW, drawH); ctx.globalAlpha = 1.0; 
                }
                historyStack.forEach(el => renderDraftElement(el));
                if(currentPath.length > 0) {
                    renderDraftElement({ type: mode, points: currentPath }); let lastPt = currentPath[currentPath.length - 1]; let previewPt = {x: mousePos.x, y: mousePos.y};
                    if(typedDistance !== "") { let angle = Math.atan2(mousePos.y - lastPt.y, mousePos.x - lastPt.x); let dist = parseFloat(typedDistance); previewPt = {x: lastPt.x + Math.cos(angle)*dist, y: lastPt.y + Math.sin(angle)*dist}; cadBox.style.display = 'block'; cadBox.style.left = (event.pageX + 15) + 'px'; cadBox.style.top = (event.pageY - 20) + 'px'; cadValue.textContent = typedDistance; } 
                    else if(snapPoint) { previewPt = snapPoint; ctx.beginPath(); ctx.arc(snapPoint.x, snapPoint.y, 15, 0, 2*Math.PI); ctx.fillStyle = "rgba(46, 204, 113, 0.6)"; ctx.fill(); ctx.strokeStyle = "#27ae60"; ctx.lineWidth=3; ctx.stroke(); }
                    ctx.beginPath(); ctx.moveTo(lastPt.x, lastPt.y); ctx.lineTo(previewPt.x, previewPt.y); ctx.strokeStyle = "rgba(41, 128, 185, 0.7)"; ctx.lineWidth = 3; ctx.setLineDash([10, 10]); ctx.stroke(); ctx.setLineDash([]);
                }
                drawTexts(historyStack, false);
            } else {
                ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.lineWidth = 2; ctx.lineCap = 'round';
                finalSegments.forEach((s, idx) => {
                    ctx.strokeStyle = (idx === hoverSegmentIdx && (editMode==='trim'||editMode==='smartText')) ? "#e74c3c" : "#000000"; ctx.lineWidth = (idx === hoverSegmentIdx) ? 6 : 2; 
                    if (s.dash) ctx.setLineDash([15, 15]); else ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(s.A.x, s.A.y); ctx.lineTo(s.B.x, s.B.y); ctx.stroke();
                }); ctx.setLineDash([]); 
                if(editMode === 'editLine' && hoveredNode && !draggedNode) { let pt = hoveredNode.isA ? finalSegments[hoveredNode.segIdx].A : finalSegments[hoveredNode.segIdx].B; ctx.beginPath(); ctx.arc(pt.x, pt.y, 15, 0, 2*Math.PI); ctx.fillStyle = "rgba(46, 204, 113, 0.6)"; ctx.fill(); ctx.strokeStyle = "#27ae60"; ctx.lineWidth=3; ctx.stroke(); }
                drawTexts(finalTexts, true);
            }
        }

        function generateLineArt() {
            saveState();
            if(currentPath.length > 0 && mode !== 'text') { historyStack.push({ type: mode, points: [...currentPath] }); currentPath = []; typedDistance=""; }
            if(!isGenerated) { finalTexts = []; historyStack.forEach(el => { if (el.type === 'text') { finalTexts.push({ text: el.text, x: el.x, y: el.y, angle: el.angle || 0, fontSize: el.fontSize || 35 }); } }); }
            regenerateSegments(); isGenerated = true;
            
            document.getElementById('drawToolbar').style.display = 'none'; 
            document.getElementById('sliderPanel').style.display = 'none'; // Hide sliders
            document.getElementById('docDetailsPanel').style.display = 'flex'; 
            document.getElementById('editToolbar').style.display = 'flex'; 
            document.getElementById('exportPanel').style.display = 'flex'; 
            setEditMode('editText'); 
            
            if(!document.getElementById('docDate').value) {
                document.getElementById('docDate').value = new Date().toLocaleDateString('en-GB');
            }
        }

        function generateOfficialPDF() {
            let officeLines = document.getElementById('docOffice').value.split('\n');
            document.getElementById('printOfficeLine1').innerText = officeLines[0] || "";
            document.getElementById('printOfficeLine2').innerText = officeLines.slice(1).join('\n') || "";
            document.getElementById('printVillage').innerText = document.getElementById('docVillage').value;
            document.getElementById('printKhasra').innerText = document.getElementById('docKhasra').value;
            document.getElementById('printPatwari').innerText = document.getElementById('docPatwari').value;
            
            let dateVal = document.getElementById('docDate').value; 
            document.getElementById('printDateValue').innerText = dateVal ? dateVal : "_ _ _ _ _ _ _ _ 2026";
            
            document.getElementById('printMapImage').src = canvas.toDataURL('image/jpeg', 1.0);
            
            setTimeout(() => { window.print(); }, 300);
        }

        function downloadImage(format) { const link = document.createElement('a'); link.download = `RockTech_Map.${format}`; link.href = canvas.toDataURL(`image/${format}`, 1.0); link.click(); }
        
        function downloadSVG() {
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1600 1740" width="160mm" height="174mm" style="width:160mm; height:174mm;">\n<rect width="100%" height="100%" fill="white" stroke="none"/>\n`;
            finalSegments.forEach(s => { let dash = s.dash ? `stroke-dasharray="15,15"` : ""; svg += `<line x1="${s.A.x}" y1="${s.A.y}" x2="${s.B.x}" y2="${s.B.y}" stroke="black" stroke-width="2" stroke-linecap="round" ${dash} />\n`; });
            finalTexts.forEach(el => {
                let deg = el.angle * (180 / Math.PI); let size = el.fontSize || 35; let strokeW = Math.max(2, size/6);
                let lines = el.text.split('\n'); let lineHeight = size * 1.2; let startY = el.y - ((lines.length - 1) * lineHeight) / 2;
                let whiteTextGrp = `<text font-family="Poppins, Arial" font-size="${size}" font-weight="600" fill="white" stroke="white" stroke-width="${strokeW}" text-anchor="middle" transform="rotate(${deg}, ${el.x}, ${el.y})">\n`;
                let blackTextGrp = `<text font-family="Poppins, Arial" font-size="${size}" font-weight="600" fill="black" stroke="none" text-anchor="middle" transform="rotate(${deg}, ${el.x}, ${el.y})">\n`;
                lines.forEach((line, i) => { let lineY = startY + (i * lineHeight) + (size * 0.3); whiteTextGrp += `<tspan x="${el.x}" y="${lineY}">${line}</tspan>\n`; blackTextGrp += `<tspan x="${el.x}" y="${lineY}">${line}</tspan>\n`; });
                whiteTextGrp += `</text>\n`; blackTextGrp += `</text>\n`; svg += whiteTextGrp + blackTextGrp;
            });
            svg += `</svg>`; saveAs(new Blob([svg], {type: "image/svg+xml;charset=utf-8"}), "RockTech_Word_Shapes.svg");
        }

        document.fonts.ready.then(() => { drawCanvas(); });
    </script>
</body>
</html>
